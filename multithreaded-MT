  多线程编程对于具有如下特点的编程任务而言是非常理想的： 
      本质上是异步的；
      需要多个并发活动；
      每个活动的处理顺序可能是不确定的，或者说是随机的、不可预测的。
  这种编程任务可以被组织或划分成多个执行流，其中每个执行流都有一个指定要完成的任务。
  根据应用的不同，这些子任务可能需要计算出中间结果，然后合并为最终的输出结果。
  
  如果不是用多线程，要实现这种编程任务就需要位串行程序使用一个或多个计时器，并实现一个多路复用方案。
  
  一个串行程序需要从每个I/O终端通道来检查用户的输入；然而，有一点非常重要，程序在读取I/O终端通道时不能阻塞，因为用户输入的到达时间是不确定的，
  并且阻塞会妨碍其它I/O通道的处理。串行程序必须使用非阻塞I/O或用有计时器的阻塞I/O（以保证阻塞只是暂时的）。
  
  由于串行程序只有唯一的执行线程，因此它必须兼顾需要执行的多个任务，确保其中的某个任务不会占用过多时间，并对用户的响应时间进行合理的分配。
  这种任务类型的串行程序的使用，往往造成非常复杂的控制流，难以理解和维护。
  
  编程任务可以规划成几个执行特定函数的线程：
      UserRequesrtThread： 负责读取客户端输入，该输入可能来自I/O通道。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中。
      RequestProcessor： 该线程负责从队列中获取请求并进行处理，为第3个线程提供输出。
      ReplyThread： 负责向用户输出，将结果传回用户（如果是网络应用），或者把数据写道本地文件或数据库中。
      
      
  进程
  计算机程序只是存储在磁盘上的可执行二进制（或其他类型）文件。只有把他们加载到内存中并被操作系统使用，才拥有其生命期。
  进程（有时称为重量级进程）则是一个执行中的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。
  操作系统管理器上所有进程的执行，并为这些进程合理的分配时间。进程也可以通过派生（fork或spawn）新的进程来执行其他任务，不过因为每个新进程
  都拥有自己的内存和数据栈等，所以只能采用进程间通信（IPC）的方式共享信息。
  
  
  线程
  线程（有时候成为轻量级进程）与进程类似，不过他们是在同一个进程下执行的，并共享相同的上下文。可以将他们认为是在一个主进程或“主线程”中并行运行的一些
  “迷你进程”。
  
  线程包括开始、执行顺序和结束三部分。他有一个指令指针，用于记录当时运行的上下文。当其他线程运行时，它可以被抢占（中断）和临时挂起（也成为睡眠）——
  ——这种做法叫作让步（yielding）。
  
  一个进程中的各个线程与主线程共享同一片数据空间，因此相比于独立的进程而言，线程间的信息共享和通信更加容易。
  线程一般是以并发方式执行的，正是由于这种并行和数据共享机制，使得多任务间的协作成为可能。在单核CPU系统中，因为真正的并发是不可能的，
  所以线程的执行实际是这样规划的： 每个线程运行一小会儿，然后让步给其它线程（再次排队等待更多的CPU时间）。在整个进程的执行过程中，
  每个线程执行他自己特定的任务，在必要时和其它线程进行结果通信。
  
  如果两个或多个线程访问同一片数据，由于数据访问顺序不同，可能导致结果不一致。这种情况通常称为静态条件（race condition）。幸运的是，
  大多数线程库都有一些同步原语，以允许线程管理器控制执行和访问。
  
  另一个需要注意的问题是，线程无法给予公平的执行时间。这是因为一些函数会在完成前保持阻塞状态，如果没有专门为多线程情况进行修改，会导致CPU的时间
  分配向这些贪婪的函数倾斜。
  
  
  全局解释器锁
  python代码块的执行是由python虚拟机（又名解释其主循环）进行控制的。python在设计时是这样考虑的，在主循环中同时只能由一个控制线程在执行，
  就像单核CPU系统中的多进程一样。内存中可以有许多程序，但是在任意给定时刻只能有一个程序在运行。同理，尽管Python解释器中可以运行多个线程，
  但在任意给定时刻只有一个线程会被解释器执行。
  
  对python虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，
  python虚拟机将按照下面所述的方式执行：
      1. 设置GIL
      2. 切换进一个线程去执行
      3. 执行下面的操作之一：
              a. 指定数量的字节码指令
              b. 线程主动让出控制权（可以调用time.sleep(0)来完成）
      4. 把线程设置回睡眠状态（切换出线程）
      5. 解锁GIL
      6. 重复上述步骤
      
  当调用外部代码（即，任意C/C++扩展的内置函数）时，GIL会保持锁定，直至函数执行结束（因为在这期间没有python字节码计数）。
  编写扩展函数的程序员有能力解锁GIL，然而，作为python开发者，你并不需要担心python代码会在这些情况下被锁住。
  
  对于任意面向I/O的python例程（调用了内置的操作系统C代码的那种），GIL会在I/O调用前被释放，以允许其他线程在I/O执行的时候运行。
  而对于那些没有太多I/O操作的代码而言，更倾向于在该线程整个时间片内始终占有处理器（和GIL）
              
