  多线程编程对于具有如下特点的编程任务而言是非常理想的： 
      本质上是异步的；
      需要多个并发活动；
      每个活动的处理顺序可能是不确定的，或者说是随机的、不可预测的。
  这种编程任务可以被组织或划分成多个执行流，其中每个执行流都有一个指定要完成的任务。
  根据应用的不同，这些子任务可能需要计算出中间结果，然后合并为最终的输出结果。
  
  如果不是用多线程，要实现这种编程任务就需要位串行程序使用一个或多个计时器，并实现一个多路复用方案。
  
  一个串行程序需要从每个I/O终端通道来检查用户的输入；然而，有一点非常重要，程序在读取I/O终端通道时不能阻塞，因为用户输入的到达时间是不确定的，
  并且阻塞会妨碍其它I/O通道的处理。串行程序必须使用非阻塞I/O或用有计时器的阻塞I/O（以保证阻塞只是暂时的）。
  
  由于串行程序只有唯一的执行线程，因此它必须兼顾需要执行的多个任务，确保其中的某个任务不会占用过多时间，并对用户的响应时间进行合理的分配。
  这种任务类型的串行程序的使用，往往造成非常复杂的控制流，难以理解和维护。
  
  编程任务可以规划成几个执行特定函数的线程：
      UserRequesrtThread： 负责读取客户端输入，该输入可能来自I/O通道。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中。
      RequestProcessor： 该线程负责从队列中获取请求并进行处理，为第3个线程提供输出。
      ReplyThread： 负责向用户输出，将结果传回用户（如果是网络应用），或者把数据写道本地文件或数据库中。
      
      
  进程
  计算机程序只是存储在磁盘上的可执行二进制（或其他类型）文件。只有把他们加载到内存中并被操作系统使用，才拥有其生命期。
  进程（有时称为重量级进程）则是一个执行中的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。
  操作系统管理器上所有进程的执行，并为这些进程合理的分配时间。进程也可以通过派生（fork或spawn）新的进程来执行其他任务，不过因为每个新进程
  都拥有自己的内存和数据栈等，所以只能采用进程间通信（IPC）的方式共享信息。
  
  
  线程
  线程（有时候成为轻量级进程）与进程类似，不过他们是在同一个进程下执行的，并共享相同的上下文。可以将他们认为是在一个主进程或“主线程”中并行运行的一些
  “迷你进程”。
  
  线程包括开始、执行顺序和结束三部分。他有一个指令指针，用于记录当时运行的上下文。当其他线程运行时，它可以被抢占（中断）和临时挂起（也成为睡眠）——
  ——这种做法叫作让步（yielding）。
  
  一个进程中的各个线程与主线程共享同一片数据空间，因此相比于独立的进程而言，线程间的信息共享和通信更加容易。
  线程一般是以并发方式执行的，正是由于这种并行和数据共享机制，使得多任务间的协作成为可能。在单核CPU系统中，因为真正的并发是不可能的，
  所以线程的执行实际是这样规划的： 每个线程运行一小会儿，然后让步给其它线程（再次排队等待更多的CPU时间）。在整个进程的执行过程中，
  每个线程执行他自己特定的任务，在必要时和其它线程进行结果通信。
  
  如果两个或多个线程访问同一片数据，由于数据访问顺序不同，可能导致结果不一致。这种情况通常称为静态条件（race condition）。幸运的是，
  大多数线程库都有一些同步原语，以允许线程管理器控制执行和访问。
  
  另一个需要注意的问题是，线程无法给予公平的执行时间。这是因为一些函数会在完成前保持阻塞状态，如果没有专门为多线程情况进行修改，会导致CPU的时间
  分配向这些贪婪的函数倾斜。
  
  
  全局解释器锁
  python代码块的执行是由python虚拟机（又名解释其主循环）进行控制的。python在设计时是这样考虑的，在主循环中同时只能由一个控制线程在执行，
  就像单核CPU系统中的多进程一样。内存中可以有许多程序，但是在任意给定时刻只能有一个程序在运行。同理，尽管Python解释器中可以运行多个线程，
  但在任意给定时刻只有一个线程会被解释器执行。
  
  对python虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，
  python虚拟机将按照下面所述的方式执行：
      1. 设置GIL
      2. 切换进一个线程去执行
      3. 执行下面的操作之一：
              a. 指定数量的字节码指令
              b. 线程主动让出控制权（可以调用time.sleep(0)来完成）
      4. 把线程设置回睡眠状态（切换出线程）
      5. 解锁GIL
      6. 重复上述步骤
      
  当调用外部代码（即，任意C/C++扩展的内置函数）时，GIL会保持锁定，直至函数执行结束（因为在这期间没有python字节码计数）。
  编写扩展函数的程序员有能力解锁GIL，然而，作为python开发者，你并不需要担心python代码会在这些情况下被锁住。
  
  对于任意面向I/O的python例程（调用了内置的操作系统C代码的那种），GIL会在I/O调用前被释放，以允许其他线程在I/O执行的时候运行。
  而对于那些没有太多I/O操作的代码而言，更倾向于在该线程整个时间片内始终占有处理器（和GIL）。
  换句话说就是，I/O密集型的python程序要比计算密集型的代码能够更好地利用多线程环境。
  
  如果对源代码、解释器主循环和GIL感兴趣，可以看看Python/ceval.c文件
  
  当一个线程完成函数的执行时，他就会退出。另外，还可以通过调用诸如thread.exit()之类的退出函数，或者sys.exit()之类的退出python进程的标准方法，
  异或抛出SystemExit异常，来使线程退出。但是，不能直接“终止”一个线程————主线程退出之后，所有其它线程都会在没有清理的情况下直接退出。
  模块threading会确保在所有“重要的”子线程退出前，保持整个进程的存活。
  
  python虽然支持多线程编程，但是还需要取决于它所运行的操作系统。如下操作系统时支持多线程的：绝大多数类UNIX平台，以及windows平台。python使用兼容
  POSIX的线程，也就是众所周知的pthread。
  
  python 提供了多个模块来支持多线程编程，包括_thread、threading、和queue模块等。
  _thread模块提供了基本的线程和锁定支持；而threading模块提供了更高级别、功能更加全面的线程管理。使用queue模块，
  用户可以创建一个队列数据结构，用于在多线程之间进行共享。
  
  推荐使用更高级别的threading模块而不是_thread模块有很多原因。threading模块更加先进，有更好的线程支持，并且_thread模块中的一些属性会和threading
  模块有冲突。另一个原因是低级别的_thread模块拥有的同步原语很少（实际上只有一个），而threading模块则有很多。
  
  避免使用_thread模块的另一个原因是它对于进程何时退出没有控制。当主线程结束时，所有其它线程也都强制结束，不会发出警告或者进行适当的清理。
  至少threading模块能确保重要的子线程在进程退出之前结束。
  我们只建议那些想访问线程的更底层级别的专家使用thread模块。为了强调这一点，在python3中该模块被重命名为_thread。
  
  除了派生线程以外，_thread模块还提供了基本的同步数据结构，称为锁对象（lock object， 也叫原语锁、简单锁、互斥锁、互斥和二进制信号量）。
  如前所述，这个同步原语和线程管理是密切相关的。
  
  _thread模块的核心函数是start_new_thread()。它的参数包括函数（对象）、函数的参数以及可选的关键字参数。将专门派生新的线程来调用这个函数。
  
  _thread模块和锁对象：
      _thread模块的函数：
          start_new_thread(function, args, kwargs=None)     派生一个新的线程，使用给定的args和可选的kwargs来执行function
          allocated_lock()                                  分配LockType锁对象
          exit()                                            给线程退出指令
      LockType锁对象的方法：
          acquire（wait=None）                              尝试获取锁对象
          locked（）                                        如果获取了锁对象则返回True，否则返回False
          release（）                                       释放锁
          
  start_new_thread() 必须包含开始的两个参数，于是即使要执行的函数不需要参数，也需要传递一个空元组。
  通过使用_thread.allocate_lock()函数得到锁对象，然后通过acquire()方法取得（每个锁）。取得锁效果相当于“把锁锁上”。
  一旦锁被锁上后，就可以把它添加到锁列表locks中。
  
  threading模块的对象：
      Thread          表示一个执行线程的对象
      Lock            锁原语对象（和thread模块的锁一样）
      RLock           可重入锁对象，是单一线程可以（再次）获得已持有的锁（递归锁）
      Condition       条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或某个数据值。
      Even            条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有线程将被激活。
      Semaphore       为线程间共享的有限资源提供了一个计数器，如果没有可用资源时会被阻塞。
      BoundedSemaphore与Semaphore相似，不过它不允许超过初始值。
      Timer           与Thread相似，不过它要在运行前等待一段时间。
      Barrier         创建一个“障碍”，必须达到指定数量的线程才能继续
      
  避免使用_thead模块的另一个原因时该模块不支持守护线程这个概念，当主线程退出时，所有线程都将终止，不管他们是否仍在工作。如果你不希望发生这种行为，
  就要引入守护线程的概念了。
  threading模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请求的服务器。如果没有客户端请求，守护线程就是空闲的。
  如果把一个线程设置为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。
  
  如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来
  等待客户端请求而不做任何事情。
  
  要将一个线程设置为守护线程，需要再启动线程之前执行如下赋值语句：threading.daemon = True（调用thread.setDaemon(True)的旧方法已经弃用了）。
  同样，要检查线程的守护状态，只需要检查这个值即可（对比过去调用thread.isDaemon()的方法）。一个新的子线程会继承父线程的守护标记。
  整个python程序（可以解读为：主线程）将在所有（注意！）非守护线程退出之后才退出。
  
  
  threading模块的Thread类是主要的执行对象。它有thread模块中没有的很多函数。
              
