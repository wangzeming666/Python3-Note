os.fork()
有两种方式来实现并发性，一种方式是让每个“任务"或“进程”在单独的内在空间中工作，每个都有自已的工作内存区域。
不过，虽然进程可在单独的内存空间中执行，但除非这些进程在单独的处理器上执行，否则，实际并不是“同时”运行的。
是由操作系统把处理器的时间片分配给一个进程，用完时间片后就需退出处理器等待另一个时间片的到来。
另一种方式是在在程序中指定多个“执行线程”，让它们在相同的内存空间中工作。这称为“多线程处理”。
线程比进程更有效，因为操作系统不必为每个线程创建单独的内存空间。
新建进程用os.fork函数。但它只在POSIX系统上可用，在windows版的python中，os模块没有定义os.fork函数。
相反，windows程序员用多线程编程技术来完成并发任务。
os.fork函数创建进程的过程是这样的。程序每次执行时，操作系统都会创建一个新进程来运行程序指令。
进程还可调用os.fork，要求操作系统新建一个进程。父进程是调用os.fork函数的进程。父进程所创建的进程叫子进程。
每个进程都有一个不重复的进程ID号。或称pid，它对进程进行标识。子进程与父进程完全相同，子进程从父进程继承了多个值的拷贝，如全局变量和环境变量。
两个进程的唯一区别是fork的返回值。子进程接收返回值0，而父进程接收子进程的pid作为返回值。一个现有进程可以调用fork函数创建一个新进程。
由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。
对于程序，只要判断fork的返回值，就知道自己是处于父进程还是子进程中。
子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。
注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间，它们之间共享的存储空间只有代码段。
用os.fork创建的子进程和父进程作为异步的并发进程而单独执行。异步是指它们各行其是，相互间不进行同步；并发是指它们可同时执行。
所以我们无法知道子进程和父进程的相对速度。
os.wait函数用于等待子进程结束(只适用于UNIX兼容系统)。
该函数返回包含两个元素的元组，包括已完成的子进程号pid，以及子进程的退出状态，返回状态为0，表明子进程成功完成。
返回状态为正整数表明子进程终止时出错。如没有子进程，会引发OSError错误。os.wait要求父进程等待它的任何一个子进程结束执行，然后唤醒父进程。

要指示父进程等候一个指定的子进程终止，可在父进程中使用os.waitpid函数(只适用于unix兼容系统)。
它可等候一个指定进程结束，然后返回一个双元素元组，其中包括子进程的pid和子进程的退出状态。
函数调用将pid作为第一个参数传递，并将一个选项作为第二个选项，如果第一个参数大于 0，则waitpid会等待该pid结束，如果第一个参数是-1，
则会等候所有子进程，也就和os.wait一样。
用os.system 和 os.exec函数族来执行系统命令和其它程序。os.system使用shell来执行系统。
