容易忽略的放在前面
服务器可能会设置一些socket选项（这是可选的，上面的代码就设置了，为了在杀死或重启服务器后，立马就能再次重用相同的地址）。
Python
listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)


服务器建立连接的步骤

    服务器创建一个TCP/IP socket。在Python里使用下面的语句即可：
    Python
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    	
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    然后，服务器绑定指定地址，bind函数分配一个本地地址给socket。在TCP中，调用bind可以指定一个端口号，一个IP地址，两者都，或者两者都不指定。
    Python
    listen_socket.bind(SERVER_ADDRESS)


    然后，服务器让这个socket成为监听socket。
    Python
    listen_socket.listen(REQUEST_QUEUE_SIZE)
 

    listen方法只会被服务器调用。它告诉内核它要接受这个socket上的到来的连接请求了。

做完这些后，服务器开始循环地一次接受一个客户端连接。当有连接到达时，aceept调用返回已连接的客户端socket。
然后，服务器从这个socket读取请求数据，在标准输出上把数据打印出来，并回发一个消息给客户端。然后，服务器关闭客户端连接，准备好再次接受新的客户端连接。


以下是客户端连接服务器，发送请求并打印响应的示例代码：
 import socket

 # create a socket and connect to a server
 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 sock.connect(('localhost', 8888))

 # send and receive some data
 sock.sendall(b'test')
 data = sock.recv(1024)
 print(data.decode())
 
 
创建socket后，客户端需要连接服务器。这是通过connect调用做到的：
sock.connect(('localhost', 8888))

客户端仅需提供要连接的远程IP地址或主机名和远程端口号即可。

可能你注意到了，客户端不用调用bind和accept。客户端没必要调用bind，是因为客户端不关心本地IP地址和本地端口号。当客户端调用connect时内核的
TCP/IP栈自动分配一个本地IP址地和本地端口。本地端口被称为暂时端口（ ephemeral port），也就是，short-lived 端口。

服务器上标识着一个客户端连接的众所周知的服务的端口被称为well-known端口（举例来说，80就是HTTP，22就是SSH）。操起Python shell，
创建个连接到本地服务器的客户端连接，看看内核分配给你创建的socket的暂时的端口是多少（在这之前启动webserver3a.py或webserver3b.py）：

# 交互式服务器 - webserver3.py
#
# Python 3.4 on Ubuntu 16.04

import socket

import time

SERVER_ADDRESS = (HOST, PORT) = '', 8000
REQUEST_QUEUE_SIZE = 5


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(request.decode())
    http_response = b'''
    HTTP/1.1 200 OK

    Hello, World!
    '''
    client_connection.sendall(http_response)
    time.sleep(10)


def server_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    while True:
        client_connection, client_address = listen_socket.accept()
        handle_request(client_connection)
        client_connection.close()


if __name__ == '__main__':
    server_forever()

终端命令：

>>> import socket
>>> sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
>>> sock.connect(('localhost', 8888))
>>> host, port = sock.getsockname()[:2]
>>> host, port
('127.0.0.1', 60589)

上面这个例子中，内核分配了60589这个暂时端口。

在我开始回答第二部分提出的问题前，我需要快速讲一下几个重要的概念。你很快就知道为什么重要了。两个概念是进程和文件描述符。

什么是进程？进程就是一个正在运行的程序的实例。比如，当服务器代码执行时，它被加载进内存，运行起来的程序实例被称为进程。
内核记录了进程的一堆信息用于跟踪，进程ID就是一个例子。当你运行服务器 webserver3a.py 或 webserver3b.py 时，你就在运行一个进程了。

在控制台窗口运行webserver3b.py：

在别的控制台窗口使用ps命令获取这个进程的信息：
(注意这里的ps命令ubuntu测试失败，可通过查看PID看到进程的信息，下文有提及。)
$ ps | grep webserver3b | grep -v grep
7182 ttys003    0:00.04 python webserver3b.py

ps命令表示你确实运行了一个Python进程webserver3b。进程创建时，内核分配给它一个进程ID，也就是 PID。
在UNIX里，每个用户进程都有个父进程，父进程也有它自己的进程ID，叫做父进程ID，或者简称PPID。
假设默认你是在BASH shell里运行的服务器，那新进程的父进程ID就是BASH shell的进程ID。

自己试试，看看它是怎么工作的。再启动Python shell，这将创建一个新进程，
使用 os.getpid() 和 os.getppid() 系统调用获取Python shell进程的ID和父进程ID（BASH shell的PID）。
然后，在另一个控制台窗口运行ps命令，使用grep查找PPID(父进程ID，我的是3148)。

另一个要了解的重要概念是文件描述符。那么什么是文件描述符呢？文件描述符是当打开一个存在的文件，创建一个文件，或者创建一个socket时，
内核返回的非负整数。你可能已经听过啦，在UNIX里一切皆文件。内核使用文件描述符来追踪进程打开的文件。当你需要读或写文件时，你就用文件描述符标识它好啦。
Python给你包装成更高级别的对象来处理文件（和socket），你不必直接使用文件描述符来标识一个文件，但是，在底层，UNIX中是这样标识文件和socket的：
通过它们的整数文件描述符。

默认情况下，UNIX shell分配文件描述符0给进程的标准输入，文件描述符1给进程的标准输出，文件描述符2给标准错误。
就像我前面说的，虽然Python给了你更高级别的文件或者类文件的对象，你仍然可以使用对象的fileno()方法来获取对应的文件描述符。
回到Python shell来看看怎么做：
>>> import sys
>>> sys.stdin
<open file '<stdin>', mode 'r' at 0x102beb0c0>
>>> sys.stdin.fileno()
0
>>> sys.stdout.fileno()
1
>>> sys.stderr.fileno()
2

虽然在Python中处理文件和socket，通常使用高级的文件/socket对象，但有时候你需要直接使用文件描述符。
下面这个例子告诉你如何使用write系统调用写一个字符串到标准输出，write使用整数文件描述符做为参数：
>>> import sys
>>> import os
>>> res = os.write(sys.stdout.fileno(), 'hellon')
hello

有趣的是——应该不会惊讶到你啦，因为你已经知道在UNIX里一切皆文件——socket也有一个分配给它的文件描述符。
再说一遍，当你创建一个socket时，你得到的是一个对象而不是非负整数，但你也可以使用我前面提到的fileno()方法直接访问socket的文件描述符。

还有一件事我想说下：你注意到了吗？在第二个例子webserver3b.py中，当服务器进程在60秒的睡眠时你仍然可以用curl命令来连接。
当然啦，curl没有立刻输出什么，它只是在那挂起。但为什么服务器不接受连接，客户端也不立刻被拒绝，而是能连接服务器呢？
答案就是socket对象的listen方法和它的BACKLOG参数，我称它为 REQUEST_QUEUE_SIZE(请求队列长度)。
BACKLOG参数决定了内核为进入的连接请求准备的队列长度。
当服务器webser3b.py睡眠时，第二个curl命令可以连接到服务器，因为内核在服务器socket的进入连接请求队列上有足够的可用空间。

然而增加BACKLOG参数不会神奇地让服务器同时处理多个客户端请求，设置一个合理大点的backlog参数挺重要的，这样accept调用就不用等新连接建立起来，
立刻就能从队列里获取新的连接，然后开始处理客户端请求啦。

吼吼！你已经了解了非常多的背景知识啦。咱们快速简要重述到目前为止你都学了什么（如果你都知道啦就温习一下吧）。


    迭代服务器
    服务器socket创建流程（socket, bind, listen, accept）
    客户端连接创建流程（socket, connect）
    socket对
    socket
    临时端口和众所周知端口
    进程
    进程ID（PID），父进程ID（PPID），父子关系。
    文件描述符
    listen方法的BACKLOG参数的意义

现在我准备回答第二部分问题的答案了：“怎样才能让服务器同时处理多个请求？”或者换句话说，“怎样写一个并发服务器？”

在Unix上写一个并发服务器最简单的方法是使用fork()系统调用。

下面就是新的牛逼闪闪的并发服务器webserver3c.py的代码，它能同时处理多个客户端请求（和咱们迭代服务器例子webserver3b.py一样，每个子进程睡眠60秒）：
###########################################################################
# Concurrent server - webserver3c.py                                      #
#                                                                         #
# Tested with Python 2.7.9 & Python 3.4 on Ubuntu 14.04 & Mac OS X        #
#                                                                         #
# - Child process sleeps for 60 seconds after handling a client's request #
# - Parent and child processes close duplicate descriptors                #
#                                                                         #
###########################################################################
import os
import socket
import time

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5

def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(
        'Child PID: {pid}. Parent PID {ppid}'.format(
            pid=os.getpid(),
            ppid=os.getppid(),
        )
    )
    print(request.decode())
    http_response = b"""
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)
    time.sleep(60)

def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))
    print('Parent PID (PPID): {pid}n'.format(pid=os.getpid()))

    while True:
        client_connection, client_address = listen_socket.accept()
        pid = os.fork()
        if pid == 0:  # child
            listen_socket.close()  # close child copy
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)  # child exits here
        else:  # parent
            client_connection.close()  # close parent copy and loop over

if __name__ == '__main__':
    serve_forever()
    
像你以前那样试试用两个curl命令，自己看看，现在虽然服务器子进程在处理客户端请求时睡眠60秒，但不影响别的客户端，因为它们是被不同的完全独立的进程处理的。
你应该能看到curl命令立刻就输出了“Hello, World!”，然后挂起60秒。
你可以接着想运行多少curl命令就运行多少（嗯，几乎是任意多），它们都会立刻输出服务器的响应“Hello, Wrold”，而且不会有明显的延迟。试试看。

理解fork()的最重要的点是，你fork了一次，但它返回了两次：一个是在父进程里，一个是在子进程里。当你fork了一个新进程，子进程返回的进程ID是0。
父进程里fork返回的是子进程的PID。

我仍然记得当我第一次知道它使用它时我对fork是有多着迷。它就像魔法一样。我正读着一段连续的代码，然后“duang”的一声：
代码克隆了自己，然后就有两个相同代码的实例同时运行。我想除了魔法无法做到，我是认真哒。

当父进程fork了一个新的子进程，子进程就获取了父进程文件描述符的拷贝

你可能已经注意到啦，上面代码里的父进程关闭了客户端连接：
else:  # parent
    client_connection.close()  # close parent copy and loop over

那么，如果它的父进程关闭了同一个socket，子进程为什么还能从客户端socket读取数据呢？答案就在上图。
内核使用描述符引用计数来决定是否关闭socket。只有当描述符引用计数为0时才关闭socket。
当服务器创建一个子进程，子进程获取了父进程的文件描述符拷贝，内核增加了这些描述符的引用计数。
在一个父进程和一个子进程的场景中，客户端socket的描述符引用计数就成了2，当父进程关闭了客户端连接socket，它仅仅把引用计数减为1，
不会引发内核关闭这个socket。子进程也把父进程的listen_socket拷贝给关闭了，因为子进程不用管接受新连接，它只关心处理已经连接的客户端的请求：
listen_socket.close()  # close child copy
本文后面我会讲下如果不关闭复制的描述符会发生什么。

你从并发服务器源码看到啦，现在服务器父进程唯一的角色就是接受一个新的客户端连接，fork一个新的子进程来处理客户端请求，然后重复接受另一个客户端连接，
就没有别的事做啦。服务器父进程不处理客户端请求——它的小弟（子进程）干这事。

跑个题，我们说两个事件并发到底是什么意思呢？
当我们说两个事件并发时，我们通常表达的是它们同时发生。简单来说，这也不错，但你要知道严格定义是这样的：
如果你不能通过观察程序来知道哪个先发生的，那么这两个事件就是并发的。
又到了简要重述目前为止已经学习的知识点和概念的时间啦.

    在Unix下写一个并发服务器最简单的方法是使用fork()系统调用
    当一个进程fork了一个新进程时，它就变成了那个新fork产生的子进程的父进程。
    在调用fork后，父进程和子进程共享相同的文件描述符。
    内核使用描述符引用计数来决定是否关闭文件/socket。
    服务器父进程的角色是：现在它干的所有活就是接受一个新连接，fork一个子进来来处理这个请求，然后循环接受新连接。

咱们来看看，如果在父进程和子进程中你不关闭复制的socket描述符会发生什么吧。以下是个修改后的版本，服务器不关闭复制的描述符，webserver3d.py：
